#!/usr/bin/env ruby

require 'abstract_method'
require 'find'
require 'http'
require 'nokogiri'
require 'open-uri'
require 'pathname'
require 'thor'
require 'zlib'

def internet_connection?
  true if open('http://www.google.com/')
rescue
  false
end

def transform_to_tagmap(bookmarks)
  tagmap = {}

  bookmarks.each do |bookmark|
    tags = bookmark.tags
    tags.each do |tag|
      if tagmap.key?(tag)
        tagmap[tag].concat([bookmark])
      else
        tagmap[tag] = [bookmark]
      end
    end
  end

  tagmap
end

# Represents a single abstract bookmark (i.e. one URL)
class Bookmark
  def initialize(name, url, tags)
    @name = name
    @url = url
    @tags = tags
  end

  def stale?
    http_client = HTTP.follow(true)
    begin
      response = http_client.get(@url)
      if response.code != 200
        puts "#{@name} at #{@url} is stale, got HTTP response code #{response.code}"
        return TRUE
      end
      return FALSE
    rescue HTTP::ConnectionError
      puts "#{@name} at #{@url} is stale, couldn't connect"
      return FALSE
    end
  end

  attr_reader :name
  attr_reader :url
  attr_reader :tags
end

# Represents an abstract concept of a group of bookmarks (not nestable)
class BookmarkHolder
  abstract_method :remove_bookmark
  abstract_method :add_bookmark
  attr_reader :bookmarks
end

# Represents a .webloc file (a BookmarkHolder that can hold only one bookmark)
class BookmarkHolderWebloc < BookmarkHolder
  def initialize(filename, tags)
    @filename = filename
    doc = File.open(filename) { |f| Nokogiri::XML(f) }
    @bookmarks = [Bookmark.new(File.basename(filename, File.extname(filename)), doc.at_xpath('//dict/string').content, tags)]
  end

  def remove_bookmark(bookmark)
    # .webloc files can only contain one bookmark
    raise 'Mismatching bookmark' unless bookmark == @bookmarks[0]
    File.delete(@filename)
    puts "Deleted #{@filename}"
  end

  def self.discover(inputdir)
    bookmarkholders = []

    Find.find(inputdir) do |file|
      next unless File.extname(file) == '.webloc'
      dirname = File.dirname(file)
      relative = Pathname.new(dirname).relative_path_from(Pathname.new(inputdir))
      tags = []
      relative.each_filename do |element|
        tags.concat([element])
      end
      bookmarkholders << BookmarkHolderWebloc.new(file, tags)
    end

    bookmarkholders
  end
end

# Represents an .html file which is an index that can contain maintain
# bookmarks. Intended to be "write-only".
class BookmarkHolderIndex < BookmarkHolder
  def initialize
    @bookmarks = []
  end

  def add_bookmark(bookmark)
    @bookmarks.concat([bookmark])
  end

  def write_to_file(filename)
    File.open(filename, 'w') do |file|
      file.write('<html><body><head>' \
                 '<style>.bookmarks { background-color: "gray" }</style>' \
                 '<script src="https://code.jquery.com/jquery-3.1.0.min.js" ' \
                 'integrity="sha256-cCueBR6CsyA4/9szpPfrX3s49M9vUU5BgtiJj06wt/s=" crossorigin="anonymous"></script>' \
                 '<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.4/css/bootstrap.min.css" ' \
                 'integrity="sha384-2hfp1SzUoho7/TsGGGDaFdsuuDL0LX2hnUp6VkX3CUQ2K4K+xjboZdsXyp4oUHZj" crossorigin="anonymous">' \
                 '<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.4/js/bootstrap.min.js" ' \
                 'integrity="sha384-VjEeINv9OSwtWFLAtmc4JCtEJXXBub00gtSnszmspDLCtC0I4z4nqz7rEFbIZLLU" ' \
                 'crossorigin="anonymous"></script>' \
                 '</head>')
      tagmap = transform_to_tagmap(@bookmarks)
      tagmap.each do |tag, bookmark_list|
        crc_tag = 'z' + Zlib.crc32(tag).to_s
        file.write("<a data-toggle='collapse' href='##{crc_tag}'>#{tag}</a>&nbsp;")
        file.write("<div class='bookmarks collapse' id='#{crc_tag}'>")
        bookmark_list.each do |bookmark|
          file.write("<p><a href='#{bookmark.url}'>#{bookmark.name}</a></p>")
        end
        file.write('</div>')
      end
      file.write('</body></html>')
    end
  end

  def self.discover(_inputdir)
    raise 'Discovery does not exist for index files'
  end
end

# General Thor class used to model the top-level behaviour of
# bookmark-toolbox.
class BookmarkToolbox < Thor
  desc 'findstale INPUTDIRS', 'Find stale bookmarks in INPUTDIRS'
  options inputdirs: :string
  method_option :delete, aliases: '-d', desc: 'Delete/remove stale bookmarks', type: :boolean
  def findstale(inputdirs)
    unless internet_connection?
      abort 'Internet connection not available; making stale check invalid. Aborting.'
    end

    # FIXME: Find a way to make the input an array of directories

    bookmarkholders = _getbookmarkholders([inputdirs])

    puts "Read #{bookmarkholders.length} bookmark holders"
    delete_file = options[:delete]
    bookmarkholders.each do |bookmarkholder|
      bookmarkholder.bookmarks.each do |bookmark|
        next unless bookmark.stale?
        bookmarkholder.remove_bookmark(bookmark) if delete_file
      end
    end
  end

  desc 'convertto INPUTDIRS TYPE TARGET', 'Convert bookmarks in INPUTDIRS to TYPE at TARGET'
  options inputdirs: :string
  options type: :string, default: 'index'
  options target: :string
  def convertto(inputdirs, type, target)
    raise "Type can only be 'index' right now" unless type == 'index'

    bookmarkholders = _getbookmarkholders([inputdirs])

    bookmark_holder_index = BookmarkHolderIndex.new

    bookmarkholders.each do |bookmarkholder|
      bookmarkholder.bookmarks.each do |bookmark|
        bookmark_holder_index.add_bookmark(bookmark)
      end
    end

    bookmark_holder_index.write_to_file(target)
  end

  no_commands do
    def _getbookmarkholders(inputdirs)
      bookmarkholders = []

      inputdirs.each do |inputdir|
        bookmarkholders.concat(BookmarkHolderWebloc.discover(inputdir))
      end

      bookmarkholders
    end
  end
end

BookmarkToolbox.start(ARGV)
