#!/usr/bin/env ruby

require "abstract_method"
require "find"
require "http"
require "nokogiri"
require "open-uri"
require "thor"

def internet_connection?
    begin
        true if open("http://www.google.com/")
    rescue
        false
    end
end

class Bookmark
    def initialize(name, url)
        @name = name
        @url = url
    end

    def stale?()
        http_client = HTTP.follow(true)
        begin
            response = http_client.get(@url)
            if response.code != 200
                puts "#{@name} at #{@url} is stale, got HTTP response code #{response.code}"
                return TRUE
            end
            return FALSE
        rescue HTTP::ConnectionError
            puts "#{@name} at #{@url} is stale, couldn't connect"
            return FALSE
        end
    end

    def get_name()
        return @name
    end

    def get_url()
        return @url
    end
end

class BookmarkHolder
    def get_bookmarks()
        return @bookmarks
    end

    abstract_method :remove_bookmark
    abstract_method :add_bookmark
end

class BookmarkHolderWebloc < BookmarkHolder
    def initialize(filename)
        @filename = filename
        doc = File.open(filename) { |f| Nokogiri::XML(f) }
        @bookmarks = [ Bookmark.new(File.basename(filename, File.extname(filename)), @url = doc.at_xpath('//dict/string').content) ]
    end

    def remove_bookmark(bookmark)
        # .webloc files can only contain one bookmark
        raise "Mismatching bookmark" unless bookmark == @bookmarks[0]
        File.delete(@filename)
        puts "Deleted #{@filename}"
    end

    def self.discover(inputdir)
        bookmarkholders = []

        Find.find(inputdir) { |file|
            if File.extname(file) == ".webloc"
                bookmarkholders << BookmarkHolderWebloc.new(file)
            end
        }

        return bookmarkholders
    end
end

class BookmarkHolderIndex < BookmarkHolder
    def initialize()
        @bookmarks = []
    end

    def add_bookmark(bookmark)
        @bookmarks.concat([bookmark])
    end

    def write_to_file(filename)
        File.open(filename, 'w') { |file|
            file.write("<html><body><ul>")
            @bookmarks.each { |bookmark|
                file.write("<li><a href='#{bookmark.get_url}'>#{bookmark.get_name}</a></li>\n")
            }
            file.write("</ul></body></html>")
        }
    end

    def self.discover(inputdir)
        raise "Discovery does not exist for index files"
    end
end

class BookmarkToolbox < Thor
    desc "findstale INPUTDIRS", "Find stale bookmarks in INPUTDIRS"
    options :inputdirs => :string
    method_option :delete, :aliases => "-d", :desc => "Delete/remove stale bookmarks", :type => :boolean
    def findstale(inputdirs)
        if not internet_connection?()
            abort "Internet connection not available; making stale check invalid. Aborting."
        end

        # FIXME: Find a way to make the input an array of directories

        bookmarkholders = _getbookmarkholders([inputdirs])

        puts "Read #{bookmarkholders.length} bookmark holders"
        delete_file = options[:delete]
        bookmarkholders.each { |bookmarkholder|
            bookmarkholder.get_bookmarks().each { |bookmark|
                if bookmark.stale?()
                    if delete_file
                        bookmarkholder.remove_bookmark(bookmark)
                    end
                end
            }
        }
    end

    desc "convertto INPUTDIRS TYPE TARGET", "Convert bookmarks in INPUTDIRS to TYPE at TARGET"
    options :inputdirs => :string
    options :type => :string, :default => "index"
    options :target => :string
    def convertto(inputdirs, type, target)
        raise "Type can only be 'index' right now" unless type == "index"

        bookmarkholders = _getbookmarkholders([inputdirs])

        bookmark_holder_index = BookmarkHolderIndex.new()

        bookmarkholders.each { |bookmarkholder|
            bookmarkholder.get_bookmarks().each { |bookmark|
                bookmark_holder_index.add_bookmark(bookmark)
            }
        }

        bookmark_holder_index.write_to_file(target)
    end

    no_commands do
        def _getbookmarkholders(inputdirs)
            bookmarkholders = []

            inputdirs.each { |inputdir|
                bookmarkholders.concat(BookmarkHolderWebloc.discover(inputdir))
            }

            return bookmarkholders
        end
    end
end

BookmarkToolbox.start(ARGV)
